<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <style type="text/css">

text {
  font-size: 11px;
  pointer-events: none;
}

text.parent {
  fill: #1f77b4;
}

circle {
  fill: #ccc;
  stroke: #999;
  pointer-events: all;
}

circle.parent {
  fill: #1f77b4;
  fill-opacity: .1;
  stroke: steelblue;
}

circle.blocked {
  fill:#BDBDB8;
  fill-opacity: .1;
}
circle.parent:hover {
  stroke: #ff7f0e;
  stroke-width: .5px;
}

circle.child:hover {
  stroke: #ff7f0e;
  stroke-width: .5px;
}

  </style>
  </head>
  <body>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="/static/bootstrap/dist/js/bootstrap.min.js" type="text/javascript"></script> 
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<link href="/static/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
<script type="text/javascript">
var w = 1280,
    h = 800,
    r = 720,
    x = d3.scale.linear().range([0, r]),
    y = d3.scale.linear().range([0, r]),
    node,
    root,
    depth = 1;

var pack = d3.layout.pack()
    .size([r, r])
    .padding(10)
    .sort(d3.descending)
    .children(function(d) { return d.gchildren; })
    .value(function(d) { return d.node_count; });

var vis = d3.select("body").append("svg")
    .attr("width", w)
    .attr("height", h)
  .append("g")
    .attr("transform", "translate(" + (w - r) / 2 + "," + (h - r) / 2 + ")");

d3.json("http://{{ domain }}/graph/bubble/5", function(data) {
  node = root = data;

  addPlaceholders(root);

  var nodes = pack.nodes(root)
      .filter(function(d) {return d.r > 1; });

  removePlaceholders(nodes);

  centerNodes(nodes);

  makePositionsRelativeToZero(nodes);

  var node = vis.selectAll(".node")
    .data(nodes)
    .enter()
    .append("g")
    .on("click", click);

  node.append("circle")
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .attr("r", function(d) {return d.r; })
    .attr("class", function(d) { return d.depth <= depth ? "parent" : "child"; })
    .attr("title", function(d) { return d.name; });

  $(".node").tooltip({'container': 'body', 'placement': 'top'});

  /*node.append("text")
    .attr("x", function(d) { return d.x; })
    .attr("y", function(d) { return d.y; })
    .attr("dy", ".35em")
    .attr("text-anchor", "middle")
    .style("opacity", function(d) { return d.r > 20 ? 1 : 0; })
    .text(function(d) { return d.depth != depth ? "" : d.name; */

  node.attr("visibility", function(d) {return d.depth > depth ? "hidden" : "visible"; });

  //d3.select(window).on("click", function() { zoom(root); });
});

function click(d) {
console.log("clicked on "+d.full_url);
  
if (d3.event.shiftKey) {  	
    if (d3.select(this).select("circle").attr("class") != "blocked")  {
	    d3.select(this).select("circle").attr("class", "blocked");
	    var linked = true;
	    var json = {
	    "url": d.full_url, 
	    "block_links": linked,
	    };
	    var send = JSON.stringify(json);
	    console.log(send);
	    var csrftoken = getCookie('csrftoken');
	    jQuery.ajax({
	        url: "http://{{ domain }}/save_blocked_site",
	        headers:{"X-CSRFToken":csrftoken},
	        type:"POST",
	        success: function(data, textStatus, jqXHR) {
	        },
	        error: function(jqXHR, textStatus, errorThrown) {
	          console.log( jqXHR.responseText );
	          return;
	        },
	        data: send,
	        async: true
	      });
    }
    else {
    	d3.select(this).select("circle").attr("class", "child"); 
	}
  }
  else {
    zoom(d);
  }
};

function zoom(d, i) {
  var k = r / d.r / 2;
  x.domain([d.x - d.r, d.x + d.r]);
  y.domain([d.y - d.r, d.y + d.r]);

  console.log("clicked on: "+d.depth);
  
  if (d.children)
    depth = d.depth + 1;
  else
    depth = d.depth;

  console.log(depth);
  
  var t = vis.transition()
      .duration(d3.event.altKey ? 7500 : 750);

  t.selectAll("circle")
      .attr("class", function(d) { return d.depth < depth ? "parent" : "child"; })
      .attr("visibility", function(d) {return d.depth > depth ? "hidden" : "visible"; })
      .attr("cx", function(d) { return x(d.x); })
      .attr("cy", function(d) { return y(d.y); })
      .attr("r", function(d) { return k * d.r; })
      .attr("title", function(d) { return d.name; });

  /*t.selectAll("text")
      .text(function(d) { return d.depth != depth ? "" : d.name; })
      .attr("visibility", function(d) {return d.depth > depth ? "hidden" : "visible"; })
      .attr("x", function(d) { return x(d.x); })
      .attr("y", function(d) { return y(d.y); })
      .style("opacity", function(d) { return k * d.r > 20 ? 1 : 0; }); */

  vis.selectAll(".node").filter(function (d) {return d.depth <= depth; }).on("click", click);
  
  $(".circle").tooltip({'container': 'body', 'placement': 'top'});

  d3.event.stopPropagation();
};

function doNothing(d) {
 // console.log("do nothing");
};

function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie != '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) == (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function addPlaceholders(node) {
  if(node.children) {
    for( var i = 0; i < node.children.length; i++ ){
          var child = node.children[i];
          addPlaceholders( child );
      }
      if(node.children.length === 1) {
        node.children.push({ name:'placeholder', children: [ { name:'placeholder', children:[] }] });
      }
  }
};

function removePlaceholders( nodes ) {
    for( var i = nodes.length - 1; i >= 0; i-- ) {
        var node = nodes[i];
        if( node.name === 'placeholder' ) {
            nodes.splice(i,1);
        } else {
            if( node.children ) {
                removePlaceholders( node.children );
            }
        }
    }
};

function centerNodes( nodes ) {
    for( var i = 0; i < nodes.length; i ++ ) {
        var node = nodes[i];
        if( node.children ) {
            if( node.children.length === 1) {
                var offset = node.x - node.children[0].x;
                node.children[0].x += offset;
                reposition(node.children[0],offset);
            }
        }
    }

    function reposition( node, offset ) {
        if(node.children) {
            for( var i = 0; i < node.children.length; i++ ) {
                node.children[i].x += offset;
                reposition( node.children[i], offset );
            }
        }
    };
};

function makePositionsRelativeToZero( nodes ) {
    //use this to have vis centered at 0,0,0 (easier for positioning)
    var offsetX = nodes[0].x;
    var offsetY = nodes[0].y;
    for( var i = 0; i < nodes.length; i ++ ) {
        var node = nodes[i];
        node.x -= offsetX;
        node.y -= offsetY;
    }
};
  </script>
  </body>
</html>
