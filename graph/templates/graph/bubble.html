<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <style type="text/css">

body
{
overflow: hidden;
}

.tooltip-inner {
  max-width: 1000px;
}

.tooltip-content {
  width:100%;
  overflow: hidden;
  overflow: ellipsis
}

circle:hover {
  fill: #6D1DAA;
  stroke: #999;
  stroke-width: 0.5px;
  pointer-events: all;
  stroke: #ff7f0e;
  stroke-width: 2px;
}

circle.parent {
  fill: #EAD9F8;
}

circle.child {
  fill: #6D1DAA;
}

circle.blocked {
  fill:#F11B38;
  fill-opacity: 0.5;
  
}

circle.blockedlinks {
  fill:#F11B38;
}

</style>
  </head>
  <body>
<script type="text/javascript">
/* Code for the graph adapted from http://bl.ocks.org/nilanjenator/4950148 */
var w = $(window).width(),
    h = $(window).height()-100,
    r = Math.min(w, h),
    x = d3.scale.linear().range([0, r]),
    y = d3.scale.linear().range([0, r]),
    node,
    root,
    depth = 0;

//set up circle packing layout
var pack = d3.layout.pack()
  .size([r, r])
  .value(function (d) { return d.node_count; })
  .padding(10)
  .sort(d3.descending)
  .children(function(d) { return d.gchildren; });

var vis = d3.select("body").append("svg")
    .attr("width", w)
    .attr("height", h)
  .append("g")
    .attr("transform", "translate(" + w / 2 + "," + h / 2 + ")");

//get blocked sites from server
var blocked_urls = [];
var blocked_links = [];
d3.json("https://{{ domain }}/blocked_sites", function (error, data) {
  if (data != null) {
    data.forEach(function(d) {
      if(d['block_links'] == true)
        blocked_links.push(d.url);
      else
        blocked_urls.push(d.url);
    });
  }
});

//get sites from the server
d3.json("https://{{ domain }}/graph/bubble_blocked", function(data) {
  root = data;
  visualize(root); 
});

//function to draw bubbles
function visualize(root) {
  //clear screen
  d3.selectAll("circle").remove();
  d3.selectAll("node").remove();

  //pack nodes, filtering out nodes that aren't seen
  var nodes = pack.nodes(root)
              .filter(function(d) {return (d.parent == root || d == root); });

  //helper functions to reposition nodes as needed
  centerNodes(nodes);
  makePositionsRelativeToZero(nodes);

  var node = vis.selectAll(".node")
    .data(nodes)
    .enter()
    .append("g");

  //append cirlces and set the appropriate classes
  node.append("circle")
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .attr("r", function(d) {return d.parent != null ? ((d.parent.children.length == 1 && d != root) ?  (d.r - 10) : d.r) : d.r ; })
    .attr("class", function(d) { 
      if (blocked_urls.length > 0 && blocked_urls.indexOf(d.full_url) != -1)
        return "blocked";
      else if (blocked_links.indexOf(d.full_url) != -1)
        return "blockedlinks";
      else
        return d == root ? "parent" : "child"; })
    .attr("title", function (d) { return d != root ? d.name : d.full_url ;});

  //activate tooltips
  $("circle").tooltip({
    'container': 'body', 
    'placement': 'top'});

  node.on("click", click);
};

//Capture keystrokes to block/unblock bubbles
var blockPressed = false;
$(window).keydown(function(evt) {
  if (evt.which == 66) { // b
    blockPressed = true;
  }
}).keyup(function(evt) {
  if (evt.which == 66) { // b
    blockPressed = false;
  }
});

var linksPressed = false;
$(window).keydown(function(evt) {
  if (evt.which == 76) { // l
    linksPressed = true;
  }
}).keyup(function(evt) {
  if (evt.which == 76) { // l
    linksPressed = false;
  }
});

var unblockPressed = false;
$(window).keydown(function(evt) {
  if (evt.which == 85) { // u
    unblockPressed = true;
  }
}).keyup(function(evt) {
  if (evt.which == 85) { // u
    unblockPressed = false;
  }
});

//click handler function
function click(d) {
var circle_class = d3.select(this).select("circle").attr("class");
var linked;
var blocked;

//block/unblock bubbles
if (unblockPressed || blockPressed || linksPressed) {  	
  if (circle_class != "parent") {  
      if (linksPressed) {
  	    d3.select(this).select("circle").attr("class", "blockedlinks");
  	    linked = true;
  	    blocked = true;
  	 }
      else if (blockPressed) {
      	d3.select(this).select("circle").attr("class", "blocked"); 
      	linked = false;
      	blocked = true;	    
  	}
  	else {
  		d3.select(this).select("circle").attr("class", "child"); 
      	linked = false;
      	blocked = false;
  	}
  }
  //send json packed with block/unblock information back to the server 
	var json = {
	    "url": d.full_url, 
	    "block_links": linked,
	    "blocked": blocked,
	    };
	var send = JSON.stringify(json);
    var csrftoken = getCookie('csrftoken');
    jQuery.ajax({
        url: "https://{{ domain }}/save_blocked_site",
        headers:{"X-CSRFToken":csrftoken},
        type:"POST",
        success: function(data, textStatus, jqXHR) {
        },
        error: function(jqXHR, textStatus, errorThrown) {
          console.log( jqXHR.responseText );
          return;
        },
        data: send,
        async: true
      });
  }
  //dive down or up into bubble graph
  else if (d.parent != null) {
    if (circle_class == "parent") {
      visualize(d.parent);
    }
    else if ((circle_class == "child") && (d.children != null)) {  
      visualize(d);
    }
  }

}

//helper function to communicate with server
function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie != '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) == (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
};

//helper function to center nodes
function centerNodes( nodes ) {
    for( var i = 0; i < nodes.length; i ++ ) {
        var node = nodes[i];
        if( node.children ) {
            if( node.children.length === 1) {
                var offset = node.x - node.children[0].x;
                node.children[0].x += offset;
                reposition(node.children[0],offset);
            }
        }
    }

    function reposition( node, offset ) {
        if(node.children) {
            for( var i = 0; i < node.children.length; i++ ) {
                node.children[i].x += offset;
                reposition( node.children[i], offset );
            }
        }
    };
};

//helper function to reposition nodes
function makePositionsRelativeToZero( nodes ) {
    //use this to have vis centered at 0,0,0 (easier for positioning)
    var offsetX = nodes[0].x;
    var offsetY = nodes[0].y;
    for( var i = 0; i < nodes.length; i ++ ) {
        var node = nodes[i];
        node.x -= offsetX;
        node.y -= offsetY;
    }
}; 
</script>
</body>
</html>
