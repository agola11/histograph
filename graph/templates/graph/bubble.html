<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <style type="text/css">

.tooltip-inner {
  max-width: 800px;
  width: auto;
}

circle:hover {
  fill: #6D1DAA;
  stroke: #999;
  stroke-width: 0.5px;
  pointer-events: all;
  stroke: #ff7f0e;
  stroke-width: 2px;
}

circle.parent {
  fill: #EAD9F8;
}

circle.child {
  fill: #6D1DAA;
}

circle.blocked {
  fill:#F11B38;
  fill-opacity: 0.5;
  
}

circle.blockedlinks {
  fill:#F11B38;
}

  </style>
  </head>
  <body>
    <!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  	<script src="/static/bootstrap/dist/js/bootstrap.min.js" type="text/javascript"></script> 
  	<script src="http://d3js.org/d3.v3.min.js"></script>
  	<link href="/static/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"> -->
<script type="text/javascript">
var w = $(window).width(),
    h = $(window).height()-100,
    r = Math.min(w, h),
    x = d3.scale.linear().range([0, r]),
    y = d3.scale.linear().range([0, r]),
    node,
    root,
    depth = 0;

var pack = d3.layout.pack()
    .size([r, r])
    .padding(10)
    .sort(d3.descending)
    .children(function(d) { return d.gchildren; })
    .value(function(d) { return d.node_count; })
    .padding(5);

var vis = d3.select("body").append("svg")
    .attr("width", w)
    .attr("height", h)
  .append("g")
    .attr("transform", "translate(" + w / 2 + "," + h / 2 + ")");

var blocked_urls = [];
var blocked_links = [];
d3.json("https://{{ domain }}/blocked_sites", function (error, data) {
  if (data != null) {
    data.forEach(function(d) {
      if(d['block_links'] == true)
        blocked_links.push(d.url);
      else
        blocked_urls.push(d.url);
    });
  }
});

d3.json("https://{{ domain }}/graph/bubble_blocked", function(data) {
  top = root = data;
  visualize(root);
});

function visualize(root) {
  d3.selectAll("circle").remove();
  d3.selectAll("node").remove();
  //addPlaceholders(root);

  var nodes = pack.nodes(root)
      .filter(function(d) {return (d.parent == root || d == root) });

  //removePlaceholders(nodes);

  centerNodes(nodes);

  makePositionsRelativeToZero(nodes);

  var node = vis.selectAll(".node")
    .data(nodes)
    .enter()
    .append("g");

  node.append("circle")
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .attr("r", function(d) {return d.parent != null ? (d.parent.children.length == 1 ?  d.r - 10 : d.r) : d.r ; })
    .attr("class", function(d) { 
      if (blocked_urls.length > 0 && blocked_urls.indexOf(d.full_url) != -1)
        return "blocked";
      else if (blocked_links.indexOf(d.full_url) != -1)
        return "blockedlinks";
      else
        return d == root ? "parent" : "child"; })
    .attr("title", function (d) { return d != root ? d.full_url : "" ;});

  $("circle").tooltip({
    'container': 'body', 
    'placement': 'top'});

  node.on("click", click);
};

function click(d) {
//console.log("clicked on "+d.full_url);
var circle_class = d3.select(this).select("circle").attr("class");
var linked;
var blocked;
var shiftPressed = d3.event.shiftKey;
var ctrlPressed = d3.event.ctrlKey;

if (shiftPressed || ctrlPressed) {  	
  if (circle_class != "parent") {  
      if (shiftPressed & ctrlPressed) {
  	    d3.select(this).select("circle").attr("class", "blockedlinks");
  	    linked = true;
  	    blocked = true;
  	 }
      else if (shiftPressed) {
      	d3.select(this).select("circle").attr("class", "blocked"); 
      	linked = false;
      	blocked = true;	    
  	}
  	else {
  		d3.select(this).select("circle").attr("class", "child"); 
      	linked = false;
      	blocked = false;
  	}
  }
	var json = {
	    "url": d.full_url, 
	    "block_links": linked,
	    "blocked": blocked,
	    };
	var send = JSON.stringify(json);
    var csrftoken = getCookie('csrftoken');
    jQuery.ajax({
        url: "https://{{ domain }}/save_blocked_site",
        headers:{"X-CSRFToken":csrftoken},
        type:"POST",
        success: function(data, textStatus, jqXHR) {
        },
        error: function(jqXHR, textStatus, errorThrown) {
          return;
        },
        data: send,
        async: true
      });
  }

  else if (d.parent != null) {
    if (circle_class == "parent") {
      visualize(d.parent);
    }
    else if ((circle_class != "blocked") && (circle_class != "blocked_links") && (d.children != null)) {  
      visualize(d);
    }
  }

}

function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie != '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) == (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
};

function addPlaceholders(node) {
  if(node.children) {
    for( var i = 0; i < node.children.length; i++ ){
          var child = node.children[i];
          addPlaceholders( child );
      }
      if(node.children.length === 1) {
        node.children.push({ name:'placeholder', children: [ { name:'placeholder', children:[] }] });
      }
  }
};

function removePlaceholders( nodes ) {
    for( var i = nodes.length - 1; i >= 0; i-- ) {
        var node = nodes[i];
        if( node.name === 'placeholder' ) {
            nodes.splice(i,1);
        } else {
            if( node.children ) {
                removePlaceholders( node.children );
            }
        }
    }
};

function centerNodes( nodes ) {
    for( var i = 0; i < nodes.length; i ++ ) {
        var node = nodes[i];
        if( node.children ) {
            if( node.children.length === 1) {
                var offset = node.x - node.children[0].x;
                node.children[0].x += offset;
                reposition(node.children[0],offset);
            }
        }
    }

    function reposition( node, offset ) {
        if(node.children) {
            for( var i = 0; i < node.children.length; i++ ) {
                node.children[i].x += offset;
                reposition( node.children[i], offset );
            }
        }
    };
};

function makePositionsRelativeToZero( nodes ) {
    //use this to have vis centered at 0,0,0 (easier for positioning)
    var offsetX = nodes[0].x;
    var offsetY = nodes[0].y;
    for( var i = 0; i < nodes.length; i ++ ) {
        var node = nodes[i];
        node.x -= offsetX;
        node.y -= offsetY;
    }
};
</script>
</body>
</html>
